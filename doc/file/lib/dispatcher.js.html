<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/dispatcher.js | redux-redux-idle-monitor API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/cchamberlain/react-redux-idle-monitor" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-configureActions">configureActions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createContext">createContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createDispatcher">createDispatcher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-defineAction">defineAction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-reset">reset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-start">start</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-stop">stop</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CURRENT_KEY">CURRENT_KEY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IDLEMONITOR_ACTIVITY">IDLEMONITOR_ACTIVITY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IDLEMONITOR_PAUSE">IDLEMONITOR_PAUSE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IS_IDLE_KEY">IS_IDLE_KEY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IS_PAUSED_KEY">IS_PAUSED_KEY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LAST_ACTIVE_KEY">LAST_ACTIVE_KEY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LAST_EVENT_KEY">LAST_EVENT_KEY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LIB_NAME">LIB_NAME</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ROOT_STATE_KEY">ROOT_STATE_KEY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TIMEOUT_ID_KEY">TIMEOUT_ID_KEY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createActionName">createActionName</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getActions">getActions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getActiveEvents">getActiveEvents</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getLevel">getLevel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getThresholds">getThresholds</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getUseFastState">getUseFastState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getUseLocalState">getUseLocalState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-configure">configure</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-createLogger">createLogger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-configureMiddleware">configureMiddleware</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-configureReducer">configureReducer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-validateOpts">validateOpts</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/dispatcher.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { assert } from &apos;chai&apos;
import { createAction } from &apos;redux-actions&apos;
import  { ROOT_STATE_KEY
        , IDLEMONITOR_ACTIVITY
        , TIMEOUT_ID_KEY
        } from &apos;./constants&apos;
import configureActions, { start } from &apos;./actions&apos;

export default function createDispatcher(context) {
  return (dispatch, getState) =&gt; {
    const stores = storesDispatcher(context)(dispatch, getState)
    const timeout = timeoutDispatcher(context, { stores })(dispatch, getState)
    const detection = detectionDispatcher(context, { stores })(dispatch, getState)
    const action = actionDispatcher(context, { timeout, stores, detection })(dispatch, getState)
    return { stores, timeout, detection, action }
  }
}

const storesDispatcher = context =&gt; (dispatch, getState) =&gt; {
  const { log, getAction, getTimeoutMS, useFastState, useLocalState, initialLastEvent } = context

  const _shouldSetFastState = newState =&gt; {
    if(!useFastState) return false
    const { lastActive, lastEvent, timeoutID } = newState
    return typeof lastActive !== &apos;undefined&apos; || lastEvent !== &apos;undefined&apos; || typeof timeoutID !== &apos;undefined&apos;
  }

  const _shouldSetLocalState = newState =&gt; {
    if(!useLocalState) return false
    const { lastActive, lastEvent } = newState
    return typeof lastActive !== &apos;undefined&apos; || lastEvent !== &apos;undefined&apos;
  }

  const _shouldSetReduxState = newState =&gt; {
    const { current, isIdle, isPaused } = newState
    return typeof current !== &apos;undefined&apos; || typeof isIdle !== &apos;undefined&apos; || typeof isPaused !== &apos;undefined&apos;
  }

  const _filterState = (newState, stateKeys) =&gt; {
    return Object.keys(newState).reduce((state, key) =&gt; {
      if(stateKeys.includes(key))
        state[key] = newState[key]
      return state
    }, {})
  }

  const fastStateKeys = [&apos;lastActive&apos;, &apos;lastEvent&apos;, &apos;timeoutID&apos;, &apos;isDetectionRunning&apos;]
  const createFastState = ( { lastEvent = initialLastEvent
                            , timeoutID } = {}) =&gt; ({ lastActive: +new Date()
                                                    , lastEvent
                                                    , timeoutID
                                                    , isDetectionRunning: false
                                                    })
  let fastState = useFastState ? createFastState() : noop()
  const setFastState = newState =&gt; {
    fastState = Object.assign({}, fastState, _filterState(newState, fastStateKeys), { lastActive: +new Date() })
    if(process.env.NODE_ENV !== &apos;production&apos;)
      log.trace({ fastState }, &apos;fastState set&apos;)
  }

  const localStateKeys = [&apos;lastActive&apos;]
  const createLocalState = ({} = {}) =&gt; ({ lastActive: +new Date() })
  if(useLocalState)
    localStorage[IDLEMONITOR_ACTIVITY] = createLocalState()
  const getLocalState = () =&gt; {
    return localStateKeys.reduce((state, key) =&gt; {
      state[key] = localStorage[`${IDLEMONITOR_ACTIVITY}_${key}`]
      return state
    }, {})
  }
  const setLocalState = (newState) =&gt; {
    localStorage[`${IDLEMONITOR_ACTIVITY}_lastActive`] = +new Date()
    Object.keys(newState).filter(key =&gt; localStateKeys.includes(key)).forEach((key) =&gt; localStorage[`${IDLEMONITOR_ACTIVITY}_${key}`] = newState[key])
    //localStorage[IDLEMONITOR_ACTIVITY] = Object.assign({}, localStorage[IDLEMONITOR_ACTIVITY], _filterState(newState, localStateKeys), { lastActive: +new Date() })
    if(process.env.NODE_ENV !== &apos;production&apos;)
      log.trace({ localState: getLocalState() }, &apos;localState set&apos;)
  }

  /** GETS THIS LIBS SLICE OF TOP LEVEL STATE FROM REDUX (supports immutable) */
  const getLibState = () =&gt; {
    const state = getState()
    return state.isMap &amp;&amp; state.isMap() ? state.get(ROOT_STATE_KEY) : state[ROOT_STATE_KEY]
  }

  /** ABSTRACTS ACCESS TO STATE VIA GETTERS */
  const getLibStateAccessor = libState =&gt; {
              /** The current state name */
    return  { get current() { return libState.current }
              /** Is in idle state (no more states to progress to) */
            , get isIdle() { return libState.isIdle }
              /** State can be paused manually or via action dispatch or returning null/undefined from timeoutMS function */
            , get isPaused() { return libState.isPaused }
              /** The epoch MS that the user was last active */
            , get lastActive() { return useFastState ? fastState.lastActive : libState.lastActive }
              /** Event information captured on the last recorded user action */
            , get lastEvent() { return useFastState ? fastState.lastEvent : libState.lastEvent }
              /** The timeoutID for the current scheduled next event if it exists */
            , get timeoutID() { return useFastState ? fastState.timeoutID : libState.timeoutID }
            }
  }

  const getReduxState = () =&gt; {
    const state = getLibStateAccessor(getLibState())

    return  { ...state
            , get next() {
                const events = context.actionNames
                const nextIndex = events.indexOf(state.current) + 1
                return events[nextIndex] /** MAY BE UNDEFINED */
              }
            , get action() { return getAction(state.current) }
            , get timeoutMS() { return getTimeoutMS(state.current) }
            , get remainingMS() {
                if(state.isIdle)
                  return 0
                const remainingMS = getTimeoutMS(state.current) - (+new Date() - state.lastActive)
                return remainingMS &gt; 0 ? remainingMS : 0
              }
            }
  }


  return  { get redux() { return getReduxState() }
            /** Without some way to track fast state (mousemove events), redux gets spammed with actions */
          , get fast() { return useFastState ? fastState : getReduxState() }
            /** Things that need to be synced across tabs (lastActive, lastEvent) */
          , get local() { return {} }
            /** All state update actions flow through this, has ability to bypass redux for fast state operations or dispatch to it */
          , setState: (actionName, newState) =&gt; {
              if(_shouldSetLocalState)
                setLocalState(newState)
              if(_shouldSetFastState(newState)) {
                setFastState(newState)
                if(!_shouldSetReduxState(newState))
                  return log.debug(&apos;bypassing redux state update&apos;)
              }
              log.debug({ newState }, &apos;updating redux state&apos;)
              return dispatch(createAction(actionName)(newState))
            }
          }
}

const timeoutDispatcher = (context, { stores }) =&gt; (dispatch, getState) =&gt; {
  const { getFastState, getTimeoutMS } = context
  return  { clear: () =&gt; clearTimeout(stores.fast.timeoutID)
          , timeoutMS: actionName =&gt; {
              let result = getTimeoutMS(actionName)
              return typeof result === &apos;function&apos; ? result(dispatch, getState, _getChildContext(context)) : result
            }
          }
}

const detectionDispatcher = (context, { stores }) =&gt; (dispatch, getState) =&gt; {
  const { log, activeEvents, initialActionName, initialAction, thresholds } = context
  const { setState } = stores


  /** Detects whether the activity should trigger a redux update */
  const _shouldActivityUpdate = ({ type, pageX, pageY }) =&gt; {
    if(type !== &apos;mousemove&apos;) return true

    const { lastActive, lastEvent: { x, y } } = stores.fast
    if (typeof pageX === &apos;undefined&apos; || typeof pageY === &apos;undefined&apos;)
      return false
    if(Math.abs(pageX - x) &lt; thresholds.mouse &amp;&amp; Math.abs(pageY - y) &lt; thresholds.mouse)
      return false

    // SKIP UPDATE IF ITS UNDER THE THRESHOLD MS FROM THE LAST UPDATE
    let elapsedMS = (+new Date()) - lastActive
    if (elapsedMS &lt; thresholds.elapsedMS)
      return false
    if(process.env.NODE_ENV !== &apos;production&apos;)
      log.trace(`_shouldActivityUpdate: elapsed vs threshold =&gt; E[${elapsedMS}] &gt;= T[${thresholds.elapsedMS}], lastActive =&gt; ${lastActive}`)
    return true
  }

  const _shouldRestart = () =&gt; stores.redux.current !== initialActionName

  /** One of the event listeners triggered an activity occurrence event. This gets spammed */
  const onActivity = e =&gt; {
    if (!_shouldActivityUpdate(e))
      return
    if(_shouldRestart())
      return dispatch(start(context))
    /** THIS WILL BE ROUTED TO FAST OR LOCAL STATE IF ENABLED */
    setState(IDLEMONITOR_ACTIVITY, { lastActive: +new Date(), lastEvent: { x: e.pageX, y: e.pageY } })
  }

  return  { get isRunning() { return stores.fast.isDetectionRunning }
          , start: () =&gt; {
              if(process.env.NODE_ENV !== &apos;production&apos;)
                assert(stores.fast.isDetectionRunning === false, &apos;activity detection is already running&apos;)
              activeEvents.forEach(x =&gt; document.addEventListener(x, onActivity))
              log.debug(&apos;activity detection started...&apos;)
              setState(IDLEMONITOR_ACTIVITY, { isDetectionRunning: true })
            }
          , stop: () =&gt; {
              if(process.env.NODE_ENV !== &apos;production&apos;)
                assert(stores.fast.isDetectionRunning === true, &apos;activity detection is not running&apos;)
              activeEvents.forEach(x =&gt; document.removeEventListener(x, onActivity))
              log.debug(&apos;activity detection stopped&apos;)
              setState(IDLEMONITOR_ACTIVITY, { isDetectionRunning: false })
            }
          }

}


const actionDispatcher = (context, { timeout, stores, detection }) =&gt; (dispatch, getState) =&gt; {
  const { log, getTimeoutMS, getAction, getNextActionName, useFastState, setFastState } = context
  const { setState } = stores
  const _isPauseTriggered = timeoutMS =&gt; timeoutMS === null || timeoutMS === false || typeof timeoutMS === &apos;undefined&apos;

  /** Responsible for clearing old timeout and scheduling new one or immediately executing, returns new timeoutID or undefined */
  const schedule = actionName =&gt; {
    timeout.clear()
    const timeoutMS = timeout.timeoutMS(actionName)
    log.info({ actionName, timeoutMS }, &apos;schedule&apos;)
    const args = { actionName, isPaused: _isPauseTriggered(timeoutMS) }
    if(timeoutMS &gt; 0)
      return setTimeout(() =&gt; execute(args), timeoutMS)
    execute(args)
  }

  /** Responsible for executing an action */
  const execute = ({ actionName, isPaused }) =&gt; {
    const nextActionName = getNextActionName(actionName)
    const wasPaused = stores.redux.isPaused

    /** TODO: CHECK LOCAL STATE HERE AND IF ITS BEEN ACTIVE, POSTPONE THE ACTION ABOUT TO BE EXECUTED */

    /** SCHEDULE THE NEXT ACTION IF IT EXISTS */
    let timeoutID = nextActionName &amp;&amp; !isPaused ? schedule(nextActionName) : null

    if(isPaused &amp;&amp; !wasPaused) {
      log.warn(&apos;pausing activity detection&apos;)
      detection.stop()
    }
    if(!isPaused &amp;&amp; wasPaused)
      detection.start()

    /** UPDATE THE STATE OF THE APP */
    setState(actionName,  { current: actionName
                          , isIdle: typeof nextActionName === &apos;undefined&apos;
                          , isPaused
                          , timeoutID
                          })

    /** EXECUTE THE USER DEFINED ACTION WITH REDUX THUNK ARGS + CONTEXT (LOG, START/STOP/RESET DISPATCHABLE ACTIONS) */
    getAction(actionName)(dispatch, getState, _getChildContext(context))
  }
  return { schedule, execute }
}

const _getChildContext = context =&gt; ({ ...context, actions: configureActions(context) })
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.6)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
